"""
Malware Scan Lambda Function
Handles malware scanning of uploaded files
"""
import json
import os
import sys
from datetime import datetime

# Add shared layer to path
sys.path.insert(0, "/opt/python")

import boto3
from db_utils import execute_query
from response import (
    success_response,
    error_response,
    validation_error,
    not_found_error,
)

s3_client = boto3.client("s3")
MEDIA_BUCKET = os.environ["MEDIA_BUCKET"]


def lambda_handler(event, context):
    """Main Lambda handler for malware scanning"""
    try:
        # Parse request
        method = event.get("httpMethod")
        path = event.get("path", "")
        body = json.loads(event.get("body", "{}"))
        path_params = event.get("pathParameters", {})

        # Get user from JWT
        user_id = extract_user_id(event)
        if not user_id:
            return error_response("Unauthorized", 401)

        # Route to appropriate handler
        if method == "POST" and "/malware" in path:
            return handle_scan_request(body, user_id)
        elif method == "GET" and path_params and path_params.get("id"):
            return handle_scan_status(path_params["id"], user_id)
        else:
            return error_response("Unknown endpoint", 404)

    except Exception as e:
        print(f"Error: {str(e)}")
        return error_response("Internal server error", 500)


def extract_user_id(event):
    """Extract user ID from JWT token (simplified)"""
    # TODO: Implement proper JWT validation
    return "mock-user-id-123"


def handle_scan_request(body, user_id):
    """Initiate malware scan for a file"""
    file_id = body.get("file_id")

    if not file_id:
        return validation_error("file_id is required")

    # Fetch file metadata
    files = execute_query(
        "SELECT s3_key, original_filename FROM files WHERE id = %s AND user_id = %s",
        (file_id, user_id)
    )

    if not files:
        return not_found_error("File not found")

    file_data = files[0]

    # Download file from S3 (simplified - in production, use streaming)
    try:
        response = s3_client.get_object(
            Bucket=MEDIA_BUCKET,
            Key=file_data["s3_key"]
        )
        file_content = response["Body"].read()
    except Exception as e:
        return error_response(f"Failed to download file: {str(e)}", 500)

    # Perform malware scan (simplified - integrate with ClamAV or VirusTotal)
    scan_result = perform_malware_scan(file_content, file_data["original_filename"])

    # Update database with scan results
    execute_query(
        """
        UPDATE files
        SET malware_scan_status = %s, malware_scan_result = %s
        WHERE id = %s
        """,
        (scan_result["status"], json.dumps(scan_result), file_id),
        fetch=False
    )

    return success_response({
        "file_id": file_id,
        "scan_status": scan_result["status"],
        "scan_result": scan_result
    })


def handle_scan_status(file_id, user_id):
    """Get malware scan status for a file"""
    files = execute_query(
        """
        SELECT malware_scan_status, malware_scan_result
        FROM files
        WHERE id = %s AND user_id = %s
        """,
        (file_id, user_id)
    )

    if not files:
        return not_found_error("File not found")

    file_data = files[0]

    return success_response({
        "file_id": file_id,
        "scan_status": file_data["malware_scan_status"],
        "scan_result": file_data["malware_scan_result"]
    })


def perform_malware_scan(file_content, filename):
    """
    Perform malware scan on file content

    This is a simplified implementation. In production, integrate with:
    - ClamAV (open-source antivirus)
    - VirusTotal API
    - AWS GuardDuty Malware Protection
    """
    # Simple heuristic checks
    suspicious_patterns = [
        b"eval(",
        b"exec(",
        b"<script",
        b"javascript:",
        b"onerror=",
    ]

    threats_found = []
    for pattern in suspicious_patterns:
        if pattern in file_content:
            threats_found.append({
                "pattern": pattern.decode(),
                "severity": "medium"
            })

    if threats_found:
        return {
            "status": "malware_detected",
            "threats": threats_found,
            "scanned_at": datetime.utcnow().isoformat(),
            "engine": "simple_heuristic"
        }
    else:
        return {
            "status": "clean",
            "threats": [],
            "scanned_at": datetime.utcnow().isoformat(),
            "engine": "simple_heuristic"
        }
